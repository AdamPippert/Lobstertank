package template

import (
	"bytes"
	"fmt"
	"strings"
	"text/template"
)

// PodmanRenderer generates a Podman Compose bundle.
type PodmanRenderer struct{}

func (r *PodmanRenderer) Render(t *Template) (*InstallBundle, error) {
	hash, err := Hash(t)
	if err != nil {
		return nil, err
	}

	bundle := &InstallBundle{
		SourceHash:       hash,
		ResolvedTemplate: t,
		Files:            make(map[string][]byte),
	}

	// Generate openclaw.yaml
	oc, err := renderOpenClawConfig(t)
	if err != nil {
		return nil, fmt.Errorf("render openclaw.yaml: %w", err)
	}
	bundle.Files["openclaw.yaml"] = oc

	// Generate podman-compose.yml
	compose, err := renderPodmanCompose(t)
	if err != nil {
		return nil, fmt.Errorf("render podman-compose.yml: %w", err)
	}
	bundle.Files["podman-compose.yml"] = compose

	// Generate install.sh
	bundle.Files["install.sh"] = renderPodmanInstallScript(t)

	// Generate upgrade.sh
	bundle.Files["upgrade.sh"] = renderPodmanUpgradeScript(t)

	// Generate verify.sh
	bundle.Files["verify.sh"] = renderPodmanVerifyScript(t)

	return bundle, nil
}

func renderOpenClawConfig(t *Template) ([]byte, error) {
	tmpl := template.Must(template.New("openclaw").Parse(openclawConfigTmpl))
	var buf bytes.Buffer
	if err := tmpl.Execute(&buf, t); err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}

const openclawConfigTmpl = `# OpenClaw configuration — generated by Lobstertank
# DO NOT EDIT — re-render from the encoding template instead.

instance_name: {{ .Spec.Identity.InstanceName }}
role: {{ .Spec.Identity.Role }}
{{- if .Spec.Identity.Region }}
region: {{ .Spec.Identity.Region }}
{{- end }}
{{- if .Spec.Identity.Labels }}
labels:
{{- range $k, $v := .Spec.Identity.Labels }}
  {{ $k }}: "{{ $v }}"
{{- end }}
{{- end }}

server:
  bind_address: {{ or .Spec.Network.BindAddress "0.0.0.0" }}
{{- range .Spec.Network.Ports }}
  {{ .Name }}_port: {{ .Port }}
{{- end }}

auth:
  provider: {{ or .Spec.Secrets.Provider "builtin" }}
{{- range .Spec.Secrets.Entries }}
{{- if eq .Type "api_key" }}
  api_key_ref: "{{ .Ref }}"
{{- end }}
{{- end }}

logging:
  level: {{ or .Spec.Observability.Logging.Level "info" }}
  format: {{ or .Spec.Observability.Logging.Format "json" }}
{{- if .Spec.Observability.Logging.Destinations }}
  destinations:
{{- range .Spec.Observability.Logging.Destinations }}
    - {{ . }}
{{- end }}
{{- end }}

{{- if .Spec.Observability.Metrics.Enabled }}
metrics:
  enabled: true
  endpoint: {{ .Spec.Observability.Metrics.Endpoint }}
  format: {{ or .Spec.Observability.Metrics.Format "prometheus" }}
{{- end }}

{{- if .Spec.Observability.HealthCheck.Path }}
health_check:
  path: {{ .Spec.Observability.HealthCheck.Path }}
  interval: {{ or .Spec.Observability.HealthCheck.Interval "30s" }}
{{- end }}

policy:
  update_channel: {{ or .Spec.Policy.UpdateChannel "stable" }}
{{- if .Spec.Policy.PinnedVersion }}
  pinned_version: {{ .Spec.Policy.PinnedVersion }}
{{- end }}
{{- if .Spec.Policy.ApprovedPlugins }}
  approved_plugins:
{{- range .Spec.Policy.ApprovedPlugins }}
    - {{ . }}
{{- end }}
{{- end }}
{{- if .Spec.Policy.ApprovedProviders }}
  approved_providers:
{{- range .Spec.Policy.ApprovedProviders }}
    - {{ . }}
{{- end }}
{{- end }}
`

func renderPodmanCompose(t *Template) ([]byte, error) {
	tmpl := template.Must(template.New("compose").Funcs(template.FuncMap{
		"join":  strings.Join,
		"upper": strings.ToUpper,
	}).Parse(podmanComposeTmpl))
	var buf bytes.Buffer
	if err := tmpl.Execute(&buf, t); err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}

const podmanComposeTmpl = `# Podman Compose — generated by Lobstertank encoding template
# Instance: {{ .Spec.Identity.InstanceName }} ({{ .Spec.Identity.Role }})
# DO NOT EDIT — re-render from the encoding template instead.

services:
  openclaw:
    image: {{ or .Spec.Runtime.Image.Repository "ghcr.io/openclaw/openclaw" }}:{{ or .Spec.Runtime.Image.Tag "latest" }}
    container_name: openclaw-{{ .Spec.Identity.InstanceName }}
{{- if .Spec.Network.Ports }}
    ports:
{{- range .Spec.Network.Ports }}
      - "{{ if .HostPort }}{{ .HostPort }}{{ else }}{{ .Port }}{{ end }}:{{ .Port }}"
{{- end }}
{{- end }}
    environment:
      OPENCLAW_INSTANCE_NAME: "{{ .Spec.Identity.InstanceName }}"
      OPENCLAW_ROLE: "{{ .Spec.Identity.Role }}"
{{- if .Spec.Identity.Region }}
      OPENCLAW_REGION: "{{ .Spec.Identity.Region }}"
{{- end }}
      OPENCLAW_BIND_ADDRESS: "{{ or .Spec.Network.BindAddress "0.0.0.0" }}"
      OPENCLAW_LOG_LEVEL: "{{ or .Spec.Observability.Logging.Level "info" }}"
      OPENCLAW_LOG_FORMAT: "{{ or .Spec.Observability.Logging.Format "json" }}"
      OPENCLAW_UPDATE_CHANNEL: "{{ or .Spec.Policy.UpdateChannel "stable" }}"
{{- range .Spec.Secrets.Entries }}
      OPENCLAW_SECRET_{{ .Name | upper }}_REF: "{{ .Ref }}"
{{- end }}
    volumes:
{{- if .Spec.Runtime.Resources.StoragePaths }}
{{- range .Spec.Runtime.Resources.StoragePaths }}
      - {{ . }}
{{- end }}
{{- else }}
      - openclaw-data:/data
{{- end }}
      - ./openclaw.yaml:/etc/openclaw/config.yaml:ro
{{- if or .Spec.Runtime.Resources.CPU .Spec.Runtime.Resources.Memory }}
    deploy:
      resources:
        limits:
{{- if .Spec.Runtime.Resources.CPU }}
          cpus: "{{ .Spec.Runtime.Resources.CPU }}"
{{- end }}
{{- if .Spec.Runtime.Resources.Memory }}
          memory: {{ .Spec.Runtime.Resources.Memory }}
{{- end }}
{{- end }}
    restart: unless-stopped
    healthcheck:
      test: ["CMD", "curl", "-f", "http://localhost:{{ (index .Spec.Network.Ports 0).Port }}{{ or .Spec.Observability.HealthCheck.Path "/healthz" }}"]
      interval: {{ or .Spec.Observability.HealthCheck.Interval "30s" }}
      timeout: {{ or .Spec.Observability.HealthCheck.Timeout "5s" }}
      retries: 3
      start_period: 10s

volumes:
  openclaw-data:
`

func renderPodmanInstallScript(t *Template) []byte {
	var buf bytes.Buffer
	buf.WriteString("#!/usr/bin/env bash\n")
	buf.WriteString("# Install script — generated by Lobstertank encoding template\n")
	buf.WriteString(fmt.Sprintf("# Instance: %s (%s)\n", t.Spec.Identity.InstanceName, t.Spec.Identity.Role))
	buf.WriteString("set -euo pipefail\n\n")

	buf.WriteString("SCRIPT_DIR=\"$(cd \"$(dirname \"${BASH_SOURCE[0]}\")\" && pwd)\"\n\n")

	buf.WriteString("echo \"==> Installing OpenClaw instance: " + t.Spec.Identity.InstanceName + "\"\n\n")

	buf.WriteString("# Validate prerequisites\n")
	buf.WriteString("command -v podman >/dev/null 2>&1 || { echo \"ERROR: podman is required\"; exit 1; }\n")
	buf.WriteString("command -v podman-compose >/dev/null 2>&1 || command -v docker-compose >/dev/null 2>&1 || { echo \"ERROR: podman-compose or docker-compose is required\"; exit 1; }\n\n")

	buf.WriteString("# Determine compose command\n")
	buf.WriteString("if command -v podman-compose >/dev/null 2>&1; then\n")
	buf.WriteString("  COMPOSE_CMD=\"podman-compose\"\n")
	buf.WriteString("else\n")
	buf.WriteString("  COMPOSE_CMD=\"docker-compose\"\n")
	buf.WriteString("fi\n\n")

	buf.WriteString("# Pull images\n")
	buf.WriteString("echo \"==> Pulling container images...\"\n")
	repo := t.Spec.Runtime.Image.Repository
	if repo == "" {
		repo = "ghcr.io/openclaw/openclaw"
	}
	tag := t.Spec.Runtime.Image.Tag
	if tag == "" {
		tag = "latest"
	}
	buf.WriteString(fmt.Sprintf("podman pull %s:%s\n\n", repo, tag))

	buf.WriteString("# Start services\n")
	buf.WriteString("echo \"==> Starting services...\"\n")
	buf.WriteString("cd \"$SCRIPT_DIR\"\n")
	buf.WriteString("$COMPOSE_CMD -f podman-compose.yml up -d\n\n")

	buf.WriteString("echo \"==> Waiting for health check...\"\n")
	buf.WriteString("sleep 5\n")
	buf.WriteString("bash \"$SCRIPT_DIR/verify.sh\"\n\n")

	buf.WriteString("echo \"==> Installation complete.\"\n")
	return buf.Bytes()
}

func renderPodmanUpgradeScript(t *Template) []byte {
	var buf bytes.Buffer
	buf.WriteString("#!/usr/bin/env bash\n")
	buf.WriteString("# Upgrade script — generated by Lobstertank encoding template\n")
	buf.WriteString(fmt.Sprintf("# Instance: %s (%s)\n", t.Spec.Identity.InstanceName, t.Spec.Identity.Role))
	buf.WriteString("set -euo pipefail\n\n")

	buf.WriteString("SCRIPT_DIR=\"$(cd \"$(dirname \"${BASH_SOURCE[0]}\")\" && pwd)\"\n\n")

	buf.WriteString("echo \"==> Upgrading OpenClaw instance: " + t.Spec.Identity.InstanceName + "\"\n\n")

	buf.WriteString("# Determine compose command\n")
	buf.WriteString("if command -v podman-compose >/dev/null 2>&1; then\n")
	buf.WriteString("  COMPOSE_CMD=\"podman-compose\"\n")
	buf.WriteString("else\n")
	buf.WriteString("  COMPOSE_CMD=\"docker-compose\"\n")
	buf.WriteString("fi\n\n")

	repo := t.Spec.Runtime.Image.Repository
	if repo == "" {
		repo = "ghcr.io/openclaw/openclaw"
	}
	tag := t.Spec.Runtime.Image.Tag
	if tag == "" {
		tag = "latest"
	}

	buf.WriteString("# Pull latest image\n")
	buf.WriteString("echo \"==> Pulling latest image...\"\n")
	buf.WriteString(fmt.Sprintf("podman pull %s:%s\n\n", repo, tag))

	buf.WriteString("# Rolling restart\n")
	buf.WriteString("echo \"==> Restarting services...\"\n")
	buf.WriteString("cd \"$SCRIPT_DIR\"\n")
	buf.WriteString("$COMPOSE_CMD -f podman-compose.yml down\n")
	buf.WriteString("$COMPOSE_CMD -f podman-compose.yml up -d\n\n")

	buf.WriteString("echo \"==> Waiting for health check...\"\n")
	buf.WriteString("sleep 5\n")
	buf.WriteString("bash \"$SCRIPT_DIR/verify.sh\"\n\n")

	buf.WriteString("echo \"==> Upgrade complete.\"\n")
	return buf.Bytes()
}

func renderPodmanVerifyScript(t *Template) []byte {
	port := 8080
	if len(t.Spec.Network.Ports) > 0 {
		port = t.Spec.Network.Ports[0].Port
	}
	healthPath := t.Spec.Observability.HealthCheck.Path
	if healthPath == "" {
		healthPath = "/healthz"
	}

	var buf bytes.Buffer
	buf.WriteString("#!/usr/bin/env bash\n")
	buf.WriteString("# Verify script — generated by Lobstertank encoding template\n")
	buf.WriteString(fmt.Sprintf("# Instance: %s (%s)\n", t.Spec.Identity.InstanceName, t.Spec.Identity.Role))
	buf.WriteString("set -euo pipefail\n\n")

	buf.WriteString(fmt.Sprintf("HEALTH_URL=\"http://localhost:%d%s\"\n", port, healthPath))
	buf.WriteString("MAX_RETRIES=10\n")
	buf.WriteString("RETRY_DELAY=3\n\n")

	buf.WriteString("echo \"==> Verifying OpenClaw instance: " + t.Spec.Identity.InstanceName + "\"\n\n")

	buf.WriteString("for i in $(seq 1 $MAX_RETRIES); do\n")
	buf.WriteString("  if curl -sf \"$HEALTH_URL\" >/dev/null 2>&1; then\n")
	buf.WriteString("    echo \"==> Health check passed (attempt $i/$MAX_RETRIES)\"\n")
	buf.WriteString("    exit 0\n")
	buf.WriteString("  fi\n")
	buf.WriteString("  echo \"    Attempt $i/$MAX_RETRIES failed, retrying in ${RETRY_DELAY}s...\"\n")
	buf.WriteString("  sleep $RETRY_DELAY\n")
	buf.WriteString("done\n\n")

	buf.WriteString("echo \"ERROR: Health check failed after $MAX_RETRIES attempts\"\n")
	buf.WriteString("echo \"Check logs with: podman logs openclaw-" + t.Spec.Identity.InstanceName + "\"\n")
	buf.WriteString("exit 1\n")
	return buf.Bytes()
}
