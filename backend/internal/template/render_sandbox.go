package template

import (
	"bytes"
	"fmt"
)

// SandboxRenderer generates a minimal local-only bundle for development/testing.
type SandboxRenderer struct{}

func (r *SandboxRenderer) Render(t *Template) (*InstallBundle, error) {
	hash, err := Hash(t)
	if err != nil {
		return nil, err
	}

	bundle := &InstallBundle{
		SourceHash:       hash,
		ResolvedTemplate: t,
		Files:            make(map[string][]byte),
	}

	// Generate openclaw.yaml
	oc, err := renderOpenClawConfig(t)
	if err != nil {
		return nil, fmt.Errorf("render openclaw.yaml: %w", err)
	}
	bundle.Files["openclaw.yaml"] = oc

	// Generate a simple run script (no containers needed).
	bundle.Files["run.sh"] = renderSandboxRunScript(t)
	bundle.Files["verify.sh"] = renderSandboxVerifyScript(t)

	return bundle, nil
}

func renderSandboxRunScript(t *Template) []byte {
	port := 8080
	if len(t.Spec.Network.Ports) > 0 {
		port = t.Spec.Network.Ports[0].Port
	}

	var buf bytes.Buffer
	buf.WriteString("#!/usr/bin/env bash\n")
	buf.WriteString("# Sandbox run script — generated by Lobstertank encoding template\n")
	buf.WriteString(fmt.Sprintf("# Instance: %s (%s)\n", t.Spec.Identity.InstanceName, t.Spec.Identity.Role))
	buf.WriteString("set -euo pipefail\n\n")

	buf.WriteString("SCRIPT_DIR=\"$(cd \"$(dirname \"${BASH_SOURCE[0]}\")\" && pwd)\"\n\n")

	buf.WriteString("echo \"==> Starting OpenClaw sandbox: " + t.Spec.Identity.InstanceName + "\"\n\n")

	buf.WriteString("export OPENCLAW_CONFIG=\"$SCRIPT_DIR/openclaw.yaml\"\n")
	buf.WriteString(fmt.Sprintf("export OPENCLAW_PORT=%d\n", port))
	buf.WriteString("export OPENCLAW_DATA_DIR=\"$SCRIPT_DIR/data\"\n")
	buf.WriteString("mkdir -p \"$OPENCLAW_DATA_DIR\"\n\n")

	buf.WriteString("echo \"Configuration: $OPENCLAW_CONFIG\"\n")
	buf.WriteString(fmt.Sprintf("echo \"Listening on: http://localhost:%d\"\n\n", port))

	buf.WriteString("# Start OpenClaw directly (assumes binary is in PATH)\n")
	buf.WriteString("exec openclaw serve --config \"$OPENCLAW_CONFIG\"\n")
	return buf.Bytes()
}

func renderSandboxVerifyScript(t *Template) []byte {
	port := 8080
	if len(t.Spec.Network.Ports) > 0 {
		port = t.Spec.Network.Ports[0].Port
	}
	healthPath := t.Spec.Observability.HealthCheck.Path
	if healthPath == "" {
		healthPath = "/healthz"
	}

	var buf bytes.Buffer
	buf.WriteString("#!/usr/bin/env bash\n")
	buf.WriteString("# Sandbox verify script — generated by Lobstertank encoding template\n")
	buf.WriteString(fmt.Sprintf("# Instance: %s (%s)\n", t.Spec.Identity.InstanceName, t.Spec.Identity.Role))
	buf.WriteString("set -euo pipefail\n\n")

	buf.WriteString(fmt.Sprintf("HEALTH_URL=\"http://localhost:%d%s\"\n\n", port, healthPath))

	buf.WriteString("echo \"==> Checking $HEALTH_URL\"\n")
	buf.WriteString("if curl -sf \"$HEALTH_URL\" >/dev/null 2>&1; then\n")
	buf.WriteString("  echo \"==> Health check passed\"\n")
	buf.WriteString("else\n")
	buf.WriteString("  echo \"WARNING: Health check failed (instance may not be running)\"\n")
	buf.WriteString("  exit 1\n")
	buf.WriteString("fi\n")
	return buf.Bytes()
}
