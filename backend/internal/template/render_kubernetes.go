package template

import (
	"bytes"
	"fmt"
	"text/template"
)

// KubernetesRenderer generates Kustomize-based Kubernetes manifests.
type KubernetesRenderer struct{}

func (r *KubernetesRenderer) Render(t *Template) (*InstallBundle, error) {
	hash, err := Hash(t)
	if err != nil {
		return nil, err
	}

	bundle := &InstallBundle{
		SourceHash:       hash,
		ResolvedTemplate: t,
		Files:            make(map[string][]byte),
	}

	// Generate openclaw config as a ConfigMap data file.
	oc, err := renderOpenClawConfig(t)
	if err != nil {
		return nil, fmt.Errorf("render openclaw.yaml: %w", err)
	}
	bundle.Files["base/openclaw.yaml"] = oc

	// Generate Kubernetes manifests.
	deploy, err := renderK8sDeployment(t)
	if err != nil {
		return nil, fmt.Errorf("render deployment.yaml: %w", err)
	}
	bundle.Files["base/deployment.yaml"] = deploy

	svc, err := renderK8sService(t)
	if err != nil {
		return nil, fmt.Errorf("render service.yaml: %w", err)
	}
	bundle.Files["base/service.yaml"] = svc

	cm, err := renderK8sConfigMap(t)
	if err != nil {
		return nil, fmt.Errorf("render configmap.yaml: %w", err)
	}
	bundle.Files["base/configmap.yaml"] = cm

	kustomization := renderK8sKustomization(t)
	bundle.Files["base/kustomization.yaml"] = kustomization

	// Install / verify scripts.
	bundle.Files["install.sh"] = renderK8sInstallScript(t)
	bundle.Files["verify.sh"] = renderK8sVerifyScript(t)

	return bundle, nil
}

func renderK8sDeployment(t *Template) ([]byte, error) {
	tmpl := template.Must(template.New("deploy").Parse(k8sDeploymentTmpl))
	var buf bytes.Buffer
	if err := tmpl.Execute(&buf, t); err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}

const k8sDeploymentTmpl = `# Kubernetes Deployment — generated by Lobstertank encoding template
# Instance: {{ .Spec.Identity.InstanceName }} ({{ .Spec.Identity.Role }})
apiVersion: apps/v1
kind: Deployment
metadata:
  name: openclaw-{{ .Spec.Identity.InstanceName }}
  labels:
    app.kubernetes.io/name: openclaw
    app.kubernetes.io/instance: {{ .Spec.Identity.InstanceName }}
    lobstertank.io/role: {{ .Spec.Identity.Role }}
{{- if .Spec.Identity.Region }}
    lobstertank.io/region: {{ .Spec.Identity.Region }}
{{- end }}
spec:
  replicas: 1
  selector:
    matchLabels:
      app.kubernetes.io/name: openclaw
      app.kubernetes.io/instance: {{ .Spec.Identity.InstanceName }}
  template:
    metadata:
      labels:
        app.kubernetes.io/name: openclaw
        app.kubernetes.io/instance: {{ .Spec.Identity.InstanceName }}
        lobstertank.io/role: {{ .Spec.Identity.Role }}
    spec:
      containers:
        - name: openclaw
          image: {{ or .Spec.Runtime.Image.Repository "ghcr.io/openclaw/openclaw" }}:{{ or .Spec.Runtime.Image.Tag "latest" }}
          imagePullPolicy: {{ or .Spec.Runtime.Image.PullPolicy "IfNotPresent" }}
{{- if .Spec.Network.Ports }}
          ports:
{{- range .Spec.Network.Ports }}
            - name: {{ .Name }}
              containerPort: {{ .Port }}
              protocol: {{ or .Protocol "TCP" }}
{{- end }}
{{- end }}
          env:
            - name: OPENCLAW_INSTANCE_NAME
              value: "{{ .Spec.Identity.InstanceName }}"
            - name: OPENCLAW_ROLE
              value: "{{ .Spec.Identity.Role }}"
{{- if .Spec.Identity.Region }}
            - name: OPENCLAW_REGION
              value: "{{ .Spec.Identity.Region }}"
{{- end }}
          volumeMounts:
            - name: config
              mountPath: /etc/openclaw
              readOnly: true
            - name: data
              mountPath: /data
{{- if .Spec.Observability.HealthCheck.Path }}
          readinessProbe:
            httpGet:
              path: {{ .Spec.Observability.HealthCheck.Path }}
              port: {{ (index .Spec.Network.Ports 0).Port }}
            initialDelaySeconds: 5
            periodSeconds: 10
          livenessProbe:
            httpGet:
              path: {{ .Spec.Observability.HealthCheck.Path }}
              port: {{ (index .Spec.Network.Ports 0).Port }}
            initialDelaySeconds: 15
            periodSeconds: 20
{{- end }}
{{- if or .Spec.Runtime.Resources.CPU .Spec.Runtime.Resources.Memory }}
          resources:
            requests:
{{- if .Spec.Runtime.Resources.CPU }}
              cpu: {{ .Spec.Runtime.Resources.CPU }}
{{- end }}
{{- if .Spec.Runtime.Resources.Memory }}
              memory: {{ .Spec.Runtime.Resources.Memory }}
{{- end }}
            limits:
{{- if .Spec.Runtime.Resources.CPU }}
              cpu: {{ .Spec.Runtime.Resources.CPU }}
{{- end }}
{{- if .Spec.Runtime.Resources.Memory }}
              memory: {{ .Spec.Runtime.Resources.Memory }}
{{- end }}
{{- end }}
      volumes:
        - name: config
          configMap:
            name: openclaw-{{ .Spec.Identity.InstanceName }}-config
        - name: data
          persistentVolumeClaim:
            claimName: openclaw-{{ .Spec.Identity.InstanceName }}-data
`

func renderK8sService(t *Template) ([]byte, error) {
	tmpl := template.Must(template.New("svc").Parse(k8sServiceTmpl))
	var buf bytes.Buffer
	if err := tmpl.Execute(&buf, t); err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}

const k8sServiceTmpl = `# Kubernetes Service — generated by Lobstertank encoding template
apiVersion: v1
kind: Service
metadata:
  name: openclaw-{{ .Spec.Identity.InstanceName }}
  labels:
    app.kubernetes.io/name: openclaw
    app.kubernetes.io/instance: {{ .Spec.Identity.InstanceName }}
spec:
  type: ClusterIP
  selector:
    app.kubernetes.io/name: openclaw
    app.kubernetes.io/instance: {{ .Spec.Identity.InstanceName }}
  ports:
{{- range .Spec.Network.Ports }}
    - name: {{ .Name }}
      port: {{ .Port }}
      targetPort: {{ .Port }}
      protocol: {{ or .Protocol "TCP" }}
{{- end }}
`

func renderK8sConfigMap(t *Template) ([]byte, error) {
	tmpl := template.Must(template.New("cm").Parse(k8sConfigMapTmpl))
	var buf bytes.Buffer
	if err := tmpl.Execute(&buf, t); err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}

const k8sConfigMapTmpl = `# Kubernetes ConfigMap — generated by Lobstertank encoding template
apiVersion: v1
kind: ConfigMap
metadata:
  name: openclaw-{{ .Spec.Identity.InstanceName }}-config
  labels:
    app.kubernetes.io/name: openclaw
    app.kubernetes.io/instance: {{ .Spec.Identity.InstanceName }}
data:
  config.yaml: |
    instance_name: {{ .Spec.Identity.InstanceName }}
    role: {{ .Spec.Identity.Role }}
    logging:
      level: {{ or .Spec.Observability.Logging.Level "info" }}
      format: {{ or .Spec.Observability.Logging.Format "json" }}
    policy:
      update_channel: {{ or .Spec.Policy.UpdateChannel "stable" }}
`

func renderK8sKustomization(t *Template) []byte {
	var buf bytes.Buffer
	buf.WriteString("# Kustomization — generated by Lobstertank encoding template\n")
	buf.WriteString("apiVersion: kustomize.config.k8s.io/v1beta1\n")
	buf.WriteString("kind: Kustomization\n\n")
	buf.WriteString("resources:\n")
	buf.WriteString("  - deployment.yaml\n")
	buf.WriteString("  - service.yaml\n")
	buf.WriteString("  - configmap.yaml\n\n")
	buf.WriteString("commonLabels:\n")
	buf.WriteString(fmt.Sprintf("  app.kubernetes.io/instance: %s\n", t.Spec.Identity.InstanceName))
	buf.WriteString(fmt.Sprintf("  lobstertank.io/role: %s\n", t.Spec.Identity.Role))
	return buf.Bytes()
}

func renderK8sInstallScript(t *Template) []byte {
	var buf bytes.Buffer
	buf.WriteString("#!/usr/bin/env bash\n")
	buf.WriteString("# Kubernetes install script — generated by Lobstertank encoding template\n")
	buf.WriteString(fmt.Sprintf("# Instance: %s (%s)\n", t.Spec.Identity.InstanceName, t.Spec.Identity.Role))
	buf.WriteString("set -euo pipefail\n\n")

	buf.WriteString("SCRIPT_DIR=\"$(cd \"$(dirname \"${BASH_SOURCE[0]}\")\" && pwd)\"\n")
	buf.WriteString("NAMESPACE=\"${NAMESPACE:-default}\"\n\n")

	buf.WriteString("echo \"==> Installing OpenClaw instance: " + t.Spec.Identity.InstanceName + " (namespace: $NAMESPACE)\"\n\n")

	buf.WriteString("command -v kubectl >/dev/null 2>&1 || { echo \"ERROR: kubectl is required\"; exit 1; }\n\n")

	buf.WriteString("kubectl apply -k \"$SCRIPT_DIR/base/\" -n \"$NAMESPACE\"\n\n")

	buf.WriteString("echo \"==> Waiting for rollout...\"\n")
	buf.WriteString(fmt.Sprintf("kubectl rollout status deployment/openclaw-%s -n \"$NAMESPACE\" --timeout=120s\n\n", t.Spec.Identity.InstanceName))

	buf.WriteString("echo \"==> Installation complete.\"\n")
	return buf.Bytes()
}

func renderK8sVerifyScript(t *Template) []byte {
	var buf bytes.Buffer
	buf.WriteString("#!/usr/bin/env bash\n")
	buf.WriteString("# Kubernetes verify script — generated by Lobstertank encoding template\n")
	buf.WriteString(fmt.Sprintf("# Instance: %s (%s)\n", t.Spec.Identity.InstanceName, t.Spec.Identity.Role))
	buf.WriteString("set -euo pipefail\n\n")

	buf.WriteString("NAMESPACE=\"${NAMESPACE:-default}\"\n\n")

	buf.WriteString("echo \"==> Verifying OpenClaw instance: " + t.Spec.Identity.InstanceName + "\"\n\n")

	buf.WriteString(fmt.Sprintf("kubectl get deployment openclaw-%s -n \"$NAMESPACE\" -o wide\n", t.Spec.Identity.InstanceName))
	buf.WriteString(fmt.Sprintf("kubectl get pods -l app.kubernetes.io/instance=%s -n \"$NAMESPACE\" -o wide\n\n", t.Spec.Identity.InstanceName))

	buf.WriteString("# Check pod readiness\n")
	buf.WriteString(fmt.Sprintf("READY=$(kubectl get deployment openclaw-%s -n \"$NAMESPACE\" -o jsonpath='{.status.readyReplicas}')\n", t.Spec.Identity.InstanceName))
	buf.WriteString("if [ \"$READY\" -ge 1 ] 2>/dev/null; then\n")
	buf.WriteString("  echo \"==> Verification passed: $READY replica(s) ready\"\n")
	buf.WriteString("else\n")
	buf.WriteString("  echo \"ERROR: No ready replicas found\"\n")
	buf.WriteString("  exit 1\n")
	buf.WriteString("fi\n")
	return buf.Bytes()
}
